    get_depth(Rect {top: 5.0, bottom: 0.0, left: 5.0, right: 10.0});
    get_depth(Rect {top: 3.0, bottom: -3.0, left: -3.0, right: 3.0});
    get_depth(Rect {top: 10.0, bottom: 0.0, left: -10.0, right: 10.0});
    get_depth(Rect {top: 1.0, bottom: -9.0, left: -1.0, right: 1.0});

    pub fn intersects<T: Ord>(a: Rect<T>, b: Rect<T>) -> bool {
    a.left.max(b.left) < a.right.min(b.right) && a.bottom.max(b.bottom) < a.top.min(b.top)
}

pub fn get_rooms(prev_snapped: Rect<f64>, curr_snapped: Rect<f64>) -> HashSet<String> {
    let curr = to_tile_reg(curr_snapped);
    let prev = to_tile_reg(prev_snapped);
    
    // if depth different
    
    for x in (curr.region.left ..= curr.region.right).map(|x| (x as f64) * curr.tile_size + BOUND.left) {
        for y in (curr.region.bottom+1 ..= curr.region.top+1).map(|y| (y as f64) * curr.tile_size + BOUND.bottom) {
            // res.insert( format!("{curr.depth}:{x}:{y}") );

            format!("{}:{}:{}", 
                curr.depth,
                (x as f64) * curr.tile_size + BOUND.left,
                (y as f64 + 1.0) * curr.tile_size + BOUND.bottom
            );
        }
    }

        update_rooms(
        None,
        Rect {bottom: 0.0, top: 3.0, left: 0.0, right: 3.0},
        rooms
    );
    update_rooms(
        Some(Rect {bottom: 0.0, top: 3.0, left: 0.0, right: 3.0}),
        Rect {bottom: 2.0, top: 5.0, left: 2.0, right: 5.0},
        rooms
    );