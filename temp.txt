  

// const BOUND: Rect<f64> = Rect {top: 90.0, bottom: -90.0, left: -180.0, right: 180.0 };
// pub const BOUND: Rect<f64> = Rect {top: 10.0, bottom: 0.0, left: 0.0, right: 10.0 };

   // fn to_tile_reg(snapped_view: &Rect<f64>) -> TileRegion {
//     let (depth, tile_size) = get_depth_and_tile_size(&snapped_view);

//     let bottom = ((snapped_view.bottom - BOUND.bottom) / tile_size).floor() as usize;
//     let left = ((snapped_view.left - BOUND.left) / tile_size).floor() as usize;
//     let top = ((snapped_view.top - BOUND.bottom) / tile_size - 1.0).ceil() as usize;
//     let right = ((snapped_view.right - BOUND.left) / tile_size - 1.0).ceil() as usize;

//     TileRegion {
//         depth, 
//         tile_size,
//         tile_region: Rect { top, bottom, left, right }
//     }
// }

// fn get_depth_and_tile_size(rect: &Rect<f64>) -> (usize, f64) {
//     let mut depth = 0;
//     let mut tile_size = BOUND.right - BOUND.left;

//     let rect_size = (rect.right - rect.left).min(rect.top - rect.bottom);

//     while rect_size < tile_size {
//         tile_size /= 2.0;
//         depth += 1;
//     }

//     (depth, tile_size)
// } 

   
   let timestamps = {
                let mut map = HashMap::with_capacity(timestamps.len());
                for (id, time) in timestamps {
                    map.insert(id, time);
                }
                map
            };
   
    get_depth(Rect {top: 5.0, bottom: 0.0, left: 5.0, right: 10.0});
    get_depth(Rect {top: 3.0, bottom: -3.0, left: -3.0, right: 3.0});
    get_depth(Rect {top: 10.0, bottom: 0.0, left: -10.0, right: 10.0});
    get_depth(Rect {top: 1.0, bottom: -9.0, left: -1.0, right: 1.0});

    pub fn intersects<T: Ord>(a: Rect<T>, b: Rect<T>) -> bool {
    a.left.max(b.left) < a.right.min(b.right) && a.bottom.max(b.bottom) < a.top.min(b.top)
}

pub fn get_rooms(prev_snapped: Rect<f64>, curr_snapped: Rect<f64>) -> HashSet<String> {
    let curr = to_tile_reg(curr_snapped);
    let prev = to_tile_reg(prev_snapped);
    
    // if depth different
    
    for x in (curr.region.left ..= curr.region.right).map(|x| (x as f64) * curr.tile_size + BOUND.left) {
        for y in (curr.region.bottom+1 ..= curr.region.top+1).map(|y| (y as f64) * curr.tile_size + BOUND.bottom) {
            // res.insert( format!("{curr.depth}:{x}:{y}") );

            format!("{}:{}:{}", 
                curr.depth,
                (x as f64) * curr.tile_size + BOUND.left,
                (y as f64 + 1.0) * curr.tile_size + BOUND.bottom
            );
        }
    }

        update_rooms(
        None,
        Rect {bottom: 0.0, top: 3.0, left: 0.0, right: 3.0},
        rooms
    );
    update_rooms(
        Some(Rect {bottom: 0.0, top: 3.0, left: 0.0, right: 3.0}),
        Rect {bottom: 2.0, top: 5.0, left: 2.0, right: 5.0},
        rooms
    );